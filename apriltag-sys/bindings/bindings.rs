/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Defines a matrix structure for holding double-precision values with\n data in row-major order (i.e. index = row*ncols + col).\n\n nrows and ncols are 1-based counts with the exception that a scalar (non-matrix)\n   is represented with nrows=0 and/or ncols=0."]
#[repr(C)]
#[derive(Debug)]
pub struct matd_t {
    pub nrows: ::std::os::raw::c_uint,
    pub ncols: ::std::os::raw::c_uint,
    pub data: __IncompleteArrayField<f64>,
}
#[test]
fn bindgen_test_layout_matd_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_t>(),
        8usize,
        concat!("Size of: ", stringify!(matd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncols) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(ncols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n to zero. It is the caller's responsibility to call matd_destroy() on the\n returned matrix."]
    pub fn matd_create(rows: ::std::os::raw::c_int, cols: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n using the supplied array of data, which must contain at least rows*cols elements,\n arranged in row-major order (i.e. index = row*ncols + col). It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_data(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f64,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar\n in the case where rows=0 and/or cols=0). All data elements will be initialized\n using the supplied array of float data, which must contain at least rows*cols elements,\n arranged in row-major order (i.e. index = row*ncols + col). It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_dataf(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f32,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a square identity matrix with the given number of rows (and\n therefore columns), or a scalar with value 1 in the case where dim=0.\n It is the caller's responsibility to call matd_destroy() on the\n returned matrix."]
    pub fn matd_identity(dim: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a scalar with the supplied value 'v'. It is the caller's responsibility\n to call matd_destroy() on the returned matrix.\n\n NOTE: Scalars are different than 1x1 matrices (implementation note:\n they are encoded as 0x0 matrices). For example: for matrices A*B, A\n and B must both have specific dimensions. However, if A is a\n scalar, there are no restrictions on the size of B."]
    pub fn matd_create_scalar(v: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Retrieves the cell value for matrix 'm' at the given zero-based row and column index.\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get(
        m: *const matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the matrix cell at the given zero-based row and\n column index. Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put(
        m: *mut matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    #[doc = " Retrieves the scalar value of the given element ('m' must be a scalar).\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get_scalar(m: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the supplied scalar element ('m' must be a scalar).\n Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put_scalar(m: *mut matd_t, value: f64);
}
extern "C" {
    #[doc = " Creates an exact copy of the supplied matrix 'm'. It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_copy(m: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a copy of a subset of the supplied matrix 'a'. The subset will include\n rows 'r0' through 'r1', inclusive ('r1' >= 'r0'), and columns 'c0' through 'c1',\n inclusive ('c1' >= 'c0'). All parameters are zero-based (i.e. matd_select(a, 0, 0, 0, 0)\n will return only the first cell). Cannot be used on scalars or to extend\n beyond the number of rows/columns of 'a'. It is the caller's  responsibility to\n call matd_destroy() on the returned matrix."]
    pub fn matd_select(
        a: *const matd_t,
        r0: ::std::os::raw::c_int,
        r1: ::std::os::raw::c_int,
        c0: ::std::os::raw::c_int,
        c1: ::std::os::raw::c_int,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Prints the supplied matrix 'm' to standard output by applying the supplied\n printf format specifier 'fmt' for each individual element. Each row will\n be printed on a separate newline."]
    pub fn matd_print(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Prints the transpose of the supplied matrix 'm' to standard output by applying\n the supplied printf format specifier 'fmt' for each individual element. Each\n row will be printed on a separate newline."]
    pub fn matd_print_transpose(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Adds the two supplied matrices together, cell-by-cell, and returns the results\n as a new matrix of the same dimensions. The supplied matrices must have\n identical dimensions.  It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_add(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Adds the values of 'b' to matrix 'a', cell-by-cell, and overwrites the\n contents of 'a' with the results. The supplied matrices must have\n identical dimensions."]
    pub fn matd_add_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Subtracts matrix 'b' from matrix 'a', cell-by-cell, and returns the results\n as a new matrix of the same dimensions. The supplied matrices must have\n identical dimensions.  It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_subtract(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Subtracts the values of 'b' from matrix 'a', cell-by-cell, and overwrites the\n contents of 'a' with the results. The supplied matrices must have\n identical dimensions."]
    pub fn matd_subtract_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and\n returns the result as a new matrix of the same dimensions. It is the caller's\n responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_scale(a: *const matd_t, s: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and\n overwrites the contents of 'a' with the results."]
    pub fn matd_scale_inplace(a: *mut matd_t, s: f64);
}
extern "C" {
    #[doc = " Multiplies the two supplied matrices together (matrix product), and returns the\n results as a new matrix. The supplied matrices must have dimensions such that\n columns(a) = rows(b). The returned matrix will have a row count of rows(a)\n and a column count of columns(b). It is the caller's responsibility to call\n matd_destroy() on the returned matrix."]
    pub fn matd_multiply(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a matrix which is the transpose of the supplied matrix 'a'. It is the\n caller's responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_transpose(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the determinant of the supplied matrix 'a'."]
    pub fn matd_det(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Attempts to compute an inverse of the supplied matrix 'a' and return it as\n a new matrix. This is strictly only possible if the determinant of 'a' is\n non-zero (matd_det(a) != 0).\n\n If the determinant is zero, NULL is returned. It is otherwise the\n caller's responsibility to cope with the results caused by poorly\n conditioned matrices. (E.g.., if such a situation is likely to arise, compute\n the pseudo-inverse from the SVD.)"]
    pub fn matd_inverse(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the magnitude of the supplied matrix 'a'."]
    pub fn matd_vec_mag(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the magnitude of the distance between the points represented by\n matrices 'a' and 'b'. Both 'a' and 'b' must be vectors and have the same\n dimension (although one may be a row vector and one may be a column vector)."]
    pub fn matd_vec_dist(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Same as matd_vec_dist, but only uses the first 'n' terms to compute distance"]
    pub fn matd_vec_dist_n(a: *const matd_t, b: *const matd_t, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Calculates the dot product of two vectors. Both 'a' and 'b' must be vectors\n and have the same dimension (although one may be a row vector and one may be\n a column vector)."]
    pub fn matd_vec_dot_product(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the normalization of the supplied vector 'a' (i.e. a unit vector\n of the same dimension and orientation as 'a' with a magnitude of 1) and returns\n it as a new vector. 'a' must be a vector of any dimension and must have a\n non-zero magnitude. It is the caller's responsibility to call matd_destroy()\n on the returned matrix."]
    pub fn matd_vec_normalize(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the cross product of supplied matrices 'a' and 'b' (i.e. a x b)\n and returns it as a new matrix. Both 'a' and 'b' must be vectors of dimension\n 3, but can be either row or column vectors. It is the caller's responsibility\n to call matd_destroy() on the returned matrix."]
    pub fn matd_crossproduct(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_err_inf(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Creates a new matrix by applying a series of matrix operations, as expressed\n in 'expr', to the supplied list of matrices. Each matrix to be operated upon\n must be represented in the expression by a separate matrix placeholder, 'M',\n and there must be one matrix supplied as an argument for each matrix\n placeholder in the expression. All rules and caveats of the corresponding\n matrix operations apply to the operated-on matrices. It is the caller's\n responsibility to call matd_destroy() on the returned matrix.\n\n Available operators (in order of increasing precedence):\n   M+M   add two matrices together\n   M-M   subtract one matrix from another\n   M*M   multiply two matrices together (matrix product)\n   MM    multiply two matrices together (matrix product)\n   -M    negate a matrix\n   M^-1  take the inverse of a matrix\n   M'    take the transpose of a matrix\n\n Expressions can be combined together and grouped by enclosing them in\n parenthesis, i.e.:\n   -M(M+M+M)-(M*M)^-1\n\n Scalar values can be generated on-the-fly, i.e.:\n   M*2.2  scales M by 2.2\n   -2+M   adds -2 to all elements of M\n\n All whitespace in the expression is ignored."]
    pub fn matd_op(expr: *const ::std::os::raw::c_char, ...) -> *mut matd_t;
}
extern "C" {
    #[doc = " Frees the memory associated with matrix 'm', being the result of an earlier\n call to a matd_*() function, after which 'm' will no longer be usable."]
    pub fn matd_destroy(m: *mut matd_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_svd_t {
    pub U: *mut matd_t,
    pub S: *mut matd_t,
    pub V: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_svd_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_svd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_svd_t>(),
        24usize,
        concat!("Size of: ", stringify!(matd_svd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_svd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_svd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(S)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(V)
        )
    );
}
extern "C" {
    #[doc = " Compute a complete SVD of a matrix. The SVD exists for all\n matrices. For a matrix MxN, we will have:\n\n A = U*S*V'\n\n where A is MxN, U is MxM (and is an orthonormal basis), S is MxN\n (and is diagonal up to machine precision), and V is NxN (and is an\n orthonormal basis).\n\n The caller is responsible for destroying U, S, and V."]
    pub fn matd_svd(A: *mut matd_t) -> matd_svd_t;
}
extern "C" {
    pub fn matd_svd_flags(A: *mut matd_t, flags: ::std::os::raw::c_int) -> matd_svd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_plu_t {
    pub singular: ::std::os::raw::c_int,
    pub piv: *mut ::std::os::raw::c_uint,
    pub pivsign: ::std::os::raw::c_int,
    pub lu: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_plu_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_plu_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_plu_t>(),
        32usize,
        concat!("Size of: ", stringify!(matd_plu_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_plu_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_plu_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singular) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(singular)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(piv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pivsign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(pivsign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(lu)
        )
    );
}
extern "C" {
    pub fn matd_plu(a: *const matd_t) -> *mut matd_plu_t;
}
extern "C" {
    pub fn matd_plu_destroy(mlu: *mut matd_plu_t);
}
extern "C" {
    pub fn matd_plu_det(lu: *const matd_plu_t) -> f64;
}
extern "C" {
    pub fn matd_plu_p(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_l(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_u(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_solve(mlu: *const matd_plu_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_solve(A: *mut matd_t, b: *mut matd_t) -> *mut matd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_chol_t {
    pub is_spd: ::std::os::raw::c_int,
    pub u: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_chol_t() {
    const UNINIT: ::std::mem::MaybeUninit<matd_chol_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<matd_chol_t>(),
        16usize,
        concat!("Size of: ", stringify!(matd_chol_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_chol_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_chol_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_spd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(is_spd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn matd_chol(A: *mut matd_t) -> *mut matd_chol_t;
}
extern "C" {
    pub fn matd_chol_solve(chol: *const matd_chol_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_chol_destroy(chol: *mut matd_chol_t);
}
extern "C" {
    pub fn matd_chol_inverse(a: *mut matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_ltransposetriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_ltriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_utriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_max(m: *mut matd_t) -> f64;
}
pub type image_u8_t = image_u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x3_t = image_u8x3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x3 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x3() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8x3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8x3>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x3))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x3>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x4_t = image_u8x4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x4 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x4() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8x4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8x4>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x4))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x4>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_f32_t = image_f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_f32 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut f32,
}
#[test]
fn bindgen_test_layout_image_f32() {
    const UNINIT: ::std::mem::MaybeUninit<image_f32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_f32>(),
        24usize,
        concat!("Size of: ", stringify!(image_f32))
    );
    assert_eq!(
        ::std::mem::align_of::<image_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(image_f32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8_lut_t = image_u8_lut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8_lut {
    pub scale: f32,
    pub nvalues: ::std::os::raw::c_int,
    pub values: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8_lut() {
    const UNINIT: ::std::mem::MaybeUninit<image_u8_lut> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<image_u8_lut>(),
        16usize,
        concat!("Size of: ", stringify!(image_u8_lut))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8_lut>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8_lut))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvalues) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(nvalues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(values)
        )
    );
}
extern "C" {
    pub fn image_u8_create_stride(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        stride: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_alignment(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_f32(fim: *mut image_f32_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm(path: *const ::std::os::raw::c_char) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm_alignment(
        path: *const ::std::os::raw::c_char,
        alignment: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_copy(in_: *const image_u8_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_draw_line(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        v: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_circle(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_annulus(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r0: f32,
        r1: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_fill_line_max(
        im: *mut image_u8_t,
        lut: *const image_u8_lut_t,
        xy0: *const f32,
        xy1: *const f32,
    );
}
extern "C" {
    pub fn image_u8_clear(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_darken(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_convolve_2D(im: *mut image_u8_t, k: *const u8, ksz: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_gaussian_blur(im: *mut image_u8_t, sigma: f64, k: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_decimate(im: *mut image_u8_t, factor: f32) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_destroy(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_write_pnm(
        im: *const image_u8_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn image_u8_rotate(in_: *const image_u8_t, rad: f64, pad: u8) -> *mut image_u8_t;
}
#[doc = " Defines a structure which acts as a resize-able array ala Java's ArrayList."]
pub type zarray_t = zarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zarray {
    pub el_sz: usize,
    pub size: ::std::os::raw::c_int,
    pub alloc: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_zarray() {
    const UNINIT: ::std::mem::MaybeUninit<zarray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zarray>(),
        24usize,
        concat!("Size of: ", stringify!(zarray))
    );
    assert_eq!(
        ::std::mem::align_of::<zarray>(),
        8usize,
        concat!("Alignment of ", stringify!(zarray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(el_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Calls the supplied function for every element in the array in index order.\n HOWEVER values are passed to the function, not pointers to values. In the\n case where the zarray stores object pointers, zarray_vmap allows you to\n pass in the object's destroy function (or free) directly. Can only be used\n with zarray's which contain pointer data. The map function should have the\n following format:\n\n void map_function(element_type *element)"]
    pub fn zarray_vmap(za: *mut zarray_t, f: ::std::option::Option<unsafe extern "C" fn()>);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workerpool {
    _unused: [u8; 0],
}
pub type workerpool_t = workerpool;
pub type timeprofile_t = timeprofile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeprofile {
    pub utime: i64,
    pub stamps: *mut zarray_t,
}
#[test]
fn bindgen_test_layout_timeprofile() {
    const UNINIT: ::std::mem::MaybeUninit<timeprofile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeprofile>(),
        16usize,
        concat!("Size of: ", stringify!(timeprofile))
    );
    assert_eq!(
        ::std::mem::align_of::<timeprofile>(),
        8usize,
        concat!("Alignment of ", stringify!(timeprofile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(stamps)
        )
    );
}
pub type apriltag_family_t = apriltag_family;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_family {
    pub ncodes: u32,
    pub codes: *mut u64,
    pub width_at_border: ::std::os::raw::c_int,
    pub total_width: ::std::os::raw::c_int,
    pub reversed_border: bool,
    pub nbits: u32,
    pub bit_x: *mut u32,
    pub bit_y: *mut u32,
    pub h: u32,
    pub name: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_apriltag_family() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_family> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_family>(),
        72usize,
        concat!("Size of: ", stringify!(apriltag_family))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_family>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_family))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(ncodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(codes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_at_border) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(width_at_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(total_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reversed_border) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(reversed_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_y) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_quad_thresh_params {
    pub min_cluster_pixels: ::std::os::raw::c_int,
    pub max_nmaxima: ::std::os::raw::c_int,
    pub critical_rad: f32,
    pub cos_critical_rad: f32,
    pub max_line_fit_mse: f32,
    pub min_white_black_diff: ::std::os::raw::c_int,
    pub deglitch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apriltag_quad_thresh_params() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_quad_thresh_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_quad_thresh_params>(),
        28usize,
        concat!("Size of: ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_quad_thresh_params>(),
        4usize,
        concat!("Alignment of ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_cluster_pixels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_cluster_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_nmaxima) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_nmaxima)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).critical_rad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(critical_rad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cos_critical_rad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(cos_critical_rad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_line_fit_mse) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_line_fit_mse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_white_black_diff) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_white_black_diff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deglitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(deglitch)
        )
    );
}
pub type apriltag_detector_t = apriltag_detector;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apriltag_detector {
    pub nthreads: ::std::os::raw::c_int,
    pub quad_decimate: f32,
    pub quad_sigma: f32,
    pub refine_edges: ::std::os::raw::c_int,
    pub decode_sharpening: f64,
    pub debug: ::std::os::raw::c_int,
    pub qtp: apriltag_quad_thresh_params,
    pub tp: *mut timeprofile_t,
    pub nedges: u32,
    pub nsegments: u32,
    pub nquads: u32,
    pub tag_families: *mut zarray_t,
    pub wp: *mut workerpool_t,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_apriltag_detector() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detector>(),
        136usize,
        concat!("Size of: ", stringify!(apriltag_detector))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detector>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthreads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quad_decimate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_decimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quad_sigma) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_sigma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refine_edges) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(refine_edges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_sharpening) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(decode_sharpening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qtp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(qtp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nedges) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nedges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsegments) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nsegments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nquads) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nquads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_families) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tag_families)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wp) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(mutex)
        )
    );
}
pub type apriltag_detection_t = apriltag_detection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection {
    pub family: *mut apriltag_family_t,
    pub id: ::std::os::raw::c_int,
    pub hamming: ::std::os::raw::c_int,
    pub decision_margin: f32,
    pub H: *mut matd_t,
    pub c: [f64; 2usize],
    pub p: [[f64; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_apriltag_detection() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection>(),
        112usize,
        concat!("Size of: ", stringify!(apriltag_detection))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hamming) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(hamming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decision_margin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(decision_margin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(p)
        )
    );
}
extern "C" {
    pub fn apriltag_detector_create() -> *mut apriltag_detector_t;
}
extern "C" {
    pub fn apriltag_detector_add_family_bits(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
        bits_corrected: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn apriltag_detector_remove_family(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
    );
}
extern "C" {
    pub fn apriltag_detector_clear_families(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_destroy(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_detect(
        td: *mut apriltag_detector_t,
        im_orig: *mut image_u8_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn apriltag_detection_destroy(det: *mut apriltag_detection_t);
}
extern "C" {
    pub fn apriltag_detections_destroy(detections: *mut zarray_t);
}
extern "C" {
    pub fn apriltag_to_image(
        fam: *mut apriltag_family_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection_info_t {
    pub det: *mut apriltag_detection_t,
    pub tagsize: f64,
    pub fx: f64,
    pub fy: f64,
    pub cx: f64,
    pub cy: f64,
}
#[test]
fn bindgen_test_layout_apriltag_detection_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_detection_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).det) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(det)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tagsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(tagsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_pose_t {
    pub R: *mut matd_t,
    pub t: *mut matd_t,
}
#[test]
fn bindgen_test_layout_apriltag_pose_t() {
    const UNINIT: ::std::mem::MaybeUninit<apriltag_pose_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<apriltag_pose_t>(),
        16usize,
        concat!("Size of: ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_pose_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(t)
        )
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag using the homography method described in [1].\n @outparam pose"]
    pub fn estimate_pose_for_tag_homography(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag. This returns one or two possible poses for the\n tag, along with the object-space error of each.\n\n This uses the homography method described in [1] for the initial estimate.\n Then Orthogonal Iteration [2] is used to refine this estimate. Then [3] is\n used to find a potential second local minima and Orthogonal Iteration is\n used to refine this second estimate.\n\n [1]: E. Olson, Apriltag: A robust and flexible visual fiducial system, in\n      2011 IEEE International Conference on Robotics and Automation,\n      May 2011, pp. 34003407.\n [2]: Lu, G. D. Hager and E. Mjolsness, \"Fast and globally convergent pose\n      estimation from video images,\" in IEEE Transactions on Pattern Analysis\n      and Machine Intelligence, vol. 22, no. 6, pp. 610-622, June 2000.\n      doi: 10.1109/34.862199\n [3]: Schweighofer and A. Pinz, \"Robust Pose Estimation from a Planar Target,\"\n      in IEEE Transactions on Pattern Analysis and Machine Intelligence,\n      vol. 28, no. 12, pp. 2024-2030, Dec. 2006.  doi: 10.1109/TPAMI.2006.252\n\n @outparam err1, pose1, err2, pose2"]
    pub fn estimate_tag_pose_orthogonal_iteration(
        info: *mut apriltag_detection_info_t,
        err1: *mut f64,
        pose1: *mut apriltag_pose_t,
        err2: *mut f64,
        pose2: *mut apriltag_pose_t,
        nIters: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Estimate tag pose.\n This method is an easier to use interface to estimate_tag_pose_orthogonal_iteration.\n\n @outparam pose\n @return Object-space error of returned pose."]
    pub fn estimate_tag_pose(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    ) -> f64;
}
extern "C" {
    pub fn tag16h5_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag16h5_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag25h9_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag25h9_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag36h11_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag36h11_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle21h7_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle21h7_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle49h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle49h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCustom48h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCustom48h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard41h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard41h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard52h13_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard52h13_destroy(tf: *mut apriltag_family_t);
}
