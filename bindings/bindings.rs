/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Defines a matrix structure for holding double-precision values with"]
#[doc = " data in row-major order (i.e. index = row*ncols + col)."]
#[doc = ""]
#[doc = " nrows and ncols are 1-based counts with the exception that a scalar (non-matrix)"]
#[doc = "   is represented with nrows=0 and/or ncols=0."]
#[repr(C)]
#[derive(Debug)]
pub struct matd_t {
    pub nrows: ::std::os::raw::c_uint,
    pub ncols: ::std::os::raw::c_uint,
    pub data: __IncompleteArrayField<f64>,
}
#[test]
fn bindgen_test_layout_matd_t() {
    assert_eq!(
        ::std::mem::size_of::<matd_t>(),
        8usize,
        concat!("Size of: ", stringify!(matd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_t>())).nrows as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_t>())).ncols as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(ncols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_t>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar"]
    #[doc = " in the case where rows=0 and/or cols=0). All data elements will be initialized"]
    #[doc = " to zero. It is the caller's responsibility to call matd_destroy() on the"]
    #[doc = " returned matrix."]
    pub fn matd_create(rows: ::std::os::raw::c_int, cols: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar"]
    #[doc = " in the case where rows=0 and/or cols=0). All data elements will be initialized"]
    #[doc = " using the supplied array of data, which must contain at least rows*cols elements,"]
    #[doc = " arranged in row-major order (i.e. index = row*ncols + col). It is the caller's"]
    #[doc = " responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_data(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f64,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a double matrix with the given number of rows and columns (or a scalar"]
    #[doc = " in the case where rows=0 and/or cols=0). All data elements will be initialized"]
    #[doc = " using the supplied array of float data, which must contain at least rows*cols elements,"]
    #[doc = " arranged in row-major order (i.e. index = row*ncols + col). It is the caller's"]
    #[doc = " responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_create_dataf(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        data: *const f32,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a square identity matrix with the given number of rows (and"]
    #[doc = " therefore columns), or a scalar with value 1 in the case where dim=0."]
    #[doc = " It is the caller's responsibility to call matd_destroy() on the"]
    #[doc = " returned matrix."]
    pub fn matd_identity(dim: ::std::os::raw::c_int) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a scalar with the supplied value 'v'. It is the caller's responsibility"]
    #[doc = " to call matd_destroy() on the returned matrix."]
    #[doc = ""]
    #[doc = " NOTE: Scalars are different than 1x1 matrices (implementation note:"]
    #[doc = " they are encoded as 0x0 matrices). For example: for matrices A*B, A"]
    #[doc = " and B must both have specific dimensions. However, if A is a"]
    #[doc = " scalar, there are no restrictions on the size of B."]
    pub fn matd_create_scalar(v: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Retrieves the cell value for matrix 'm' at the given zero-based row and column index."]
    #[doc = " Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get(
        m: *const matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the matrix cell at the given zero-based row and"]
    #[doc = " column index. Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put(
        m: *mut matd_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    #[doc = " Retrieves the scalar value of the given element ('m' must be a scalar)."]
    #[doc = " Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_get_scalar(m: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Assigns the given value to the supplied scalar element ('m' must be a scalar)."]
    #[doc = " Performs more thorough validation checking than MATD_EL()."]
    pub fn matd_put_scalar(m: *mut matd_t, value: f64);
}
extern "C" {
    #[doc = " Creates an exact copy of the supplied matrix 'm'. It is the caller's"]
    #[doc = " responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_copy(m: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a copy of a subset of the supplied matrix 'a'. The subset will include"]
    #[doc = " rows 'r0' through 'r1', inclusive ('r1' >= 'r0'), and columns 'c0' through 'c1',"]
    #[doc = " inclusive ('c1' >= 'c0'). All parameters are zero-based (i.e. matd_select(a, 0, 0, 0, 0)"]
    #[doc = " will return only the first cell). Cannot be used on scalars or to extend"]
    #[doc = " beyond the number of rows/columns of 'a'. It is the caller's  responsibility to"]
    #[doc = " call matd_destroy() on the returned matrix."]
    pub fn matd_select(
        a: *const matd_t,
        r0: ::std::os::raw::c_int,
        r1: ::std::os::raw::c_int,
        c0: ::std::os::raw::c_int,
        c1: ::std::os::raw::c_int,
    ) -> *mut matd_t;
}
extern "C" {
    #[doc = " Prints the supplied matrix 'm' to standard output by applying the supplied"]
    #[doc = " printf format specifier 'fmt' for each individual element. Each row will"]
    #[doc = " be printed on a separate newline."]
    pub fn matd_print(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Prints the transpose of the supplied matrix 'm' to standard output by applying"]
    #[doc = " the supplied printf format specifier 'fmt' for each individual element. Each"]
    #[doc = " row will be printed on a separate newline."]
    pub fn matd_print_transpose(m: *const matd_t, fmt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Adds the two supplied matrices together, cell-by-cell, and returns the results"]
    #[doc = " as a new matrix of the same dimensions. The supplied matrices must have"]
    #[doc = " identical dimensions.  It is the caller's responsibility to call matd_destroy()"]
    #[doc = " on the returned matrix."]
    pub fn matd_add(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Adds the values of 'b' to matrix 'a', cell-by-cell, and overwrites the"]
    #[doc = " contents of 'a' with the results. The supplied matrices must have"]
    #[doc = " identical dimensions."]
    pub fn matd_add_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Subtracts matrix 'b' from matrix 'a', cell-by-cell, and returns the results"]
    #[doc = " as a new matrix of the same dimensions. The supplied matrices must have"]
    #[doc = " identical dimensions.  It is the caller's responsibility to call matd_destroy()"]
    #[doc = " on the returned matrix."]
    pub fn matd_subtract(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Subtracts the values of 'b' from matrix 'a', cell-by-cell, and overwrites the"]
    #[doc = " contents of 'a' with the results. The supplied matrices must have"]
    #[doc = " identical dimensions."]
    pub fn matd_subtract_inplace(a: *mut matd_t, b: *const matd_t);
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and"]
    #[doc = " returns the result as a new matrix of the same dimensions. It is the caller's"]
    #[doc = " responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_scale(a: *const matd_t, s: f64) -> *mut matd_t;
}
extern "C" {
    #[doc = " Scales all cell values of matrix 'a' by the given scale factor 's' and"]
    #[doc = " overwrites the contents of 'a' with the results."]
    pub fn matd_scale_inplace(a: *mut matd_t, s: f64);
}
extern "C" {
    #[doc = " Multiplies the two supplied matrices together (matrix product), and returns the"]
    #[doc = " results as a new matrix. The supplied matrices must have dimensions such that"]
    #[doc = " columns(a) = rows(b). The returned matrix will have a row count of rows(a)"]
    #[doc = " and a column count of columns(b). It is the caller's responsibility to call"]
    #[doc = " matd_destroy() on the returned matrix."]
    pub fn matd_multiply(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Creates a matrix which is the transpose of the supplied matrix 'a'. It is the"]
    #[doc = " caller's responsibility to call matd_destroy() on the returned matrix."]
    pub fn matd_transpose(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the determinant of the supplied matrix 'a'."]
    pub fn matd_det(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Attempts to compute an inverse of the supplied matrix 'a' and return it as"]
    #[doc = " a new matrix. This is strictly only possible if the determinant of 'a' is"]
    #[doc = " non-zero (matd_det(a) != 0)."]
    #[doc = ""]
    #[doc = " If the determinant is zero, NULL is returned. It is otherwise the"]
    #[doc = " caller's responsibility to cope with the results caused by poorly"]
    #[doc = " conditioned matrices. (E.g.., if such a situation is likely to arise, compute"]
    #[doc = " the pseudo-inverse from the SVD.)"]
    pub fn matd_inverse(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the magnitude of the supplied matrix 'a'."]
    pub fn matd_vec_mag(a: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the magnitude of the distance between the points represented by"]
    #[doc = " matrices 'a' and 'b'. Both 'a' and 'b' must be vectors and have the same"]
    #[doc = " dimension (although one may be a row vector and one may be a column vector)."]
    pub fn matd_vec_dist(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Same as matd_vec_dist, but only uses the first 'n' terms to compute distance"]
    pub fn matd_vec_dist_n(a: *const matd_t, b: *const matd_t, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Calculates the dot product of two vectors. Both 'a' and 'b' must be vectors"]
    #[doc = " and have the same dimension (although one may be a row vector and one may be"]
    #[doc = " a column vector)."]
    pub fn matd_vec_dot_product(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Calculates the normalization of the supplied vector 'a' (i.e. a unit vector"]
    #[doc = " of the same dimension and orientation as 'a' with a magnitude of 1) and returns"]
    #[doc = " it as a new vector. 'a' must be a vector of any dimension and must have a"]
    #[doc = " non-zero magnitude. It is the caller's responsibility to call matd_destroy()"]
    #[doc = " on the returned matrix."]
    pub fn matd_vec_normalize(a: *const matd_t) -> *mut matd_t;
}
extern "C" {
    #[doc = " Calculates the cross product of supplied matrices 'a' and 'b' (i.e. a x b)"]
    #[doc = " and returns it as a new matrix. Both 'a' and 'b' must be vectors of dimension"]
    #[doc = " 3, but can be either row or column vectors. It is the caller's responsibility"]
    #[doc = " to call matd_destroy() on the returned matrix."]
    pub fn matd_crossproduct(a: *const matd_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_err_inf(a: *const matd_t, b: *const matd_t) -> f64;
}
extern "C" {
    #[doc = " Creates a new matrix by applying a series of matrix operations, as expressed"]
    #[doc = " in 'expr', to the supplied list of matrices. Each matrix to be operated upon"]
    #[doc = " must be represented in the expression by a separate matrix placeholder, 'M',"]
    #[doc = " and there must be one matrix supplied as an argument for each matrix"]
    #[doc = " placeholder in the expression. All rules and caveats of the corresponding"]
    #[doc = " matrix operations apply to the operated-on matrices. It is the caller's"]
    #[doc = " responsibility to call matd_destroy() on the returned matrix."]
    #[doc = ""]
    #[doc = " Available operators (in order of increasing precedence):"]
    #[doc = "   M+M   add two matrices together"]
    #[doc = "   M-M   subtract one matrix from another"]
    #[doc = "   M*M   multiply two matrices together (matrix product)"]
    #[doc = "   MM    multiply two matrices together (matrix product)"]
    #[doc = "   -M    negate a matrix"]
    #[doc = "   M^-1  take the inverse of a matrix"]
    #[doc = "   M'    take the transpose of a matrix"]
    #[doc = ""]
    #[doc = " Expressions can be combined together and grouped by enclosing them in"]
    #[doc = " parenthesis, i.e.:"]
    #[doc = "   -M(M+M+M)-(M*M)^-1"]
    #[doc = ""]
    #[doc = " Scalar values can be generated on-the-fly, i.e.:"]
    #[doc = "   M*2.2  scales M by 2.2"]
    #[doc = "   -2+M   adds -2 to all elements of M"]
    #[doc = ""]
    #[doc = " All whitespace in the expression is ignored."]
    pub fn matd_op(expr: *const ::std::os::raw::c_char, ...) -> *mut matd_t;
}
extern "C" {
    #[doc = " Frees the memory associated with matrix 'm', being the result of an earlier"]
    #[doc = " call to a matd_*() function, after which 'm' will no longer be usable."]
    pub fn matd_destroy(m: *mut matd_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_svd_t {
    pub U: *mut matd_t,
    pub S: *mut matd_t,
    pub V: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_svd_t() {
    assert_eq!(
        ::std::mem::size_of::<matd_svd_t>(),
        24usize,
        concat!("Size of: ", stringify!(matd_svd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_svd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_svd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_svd_t>())).U as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(U)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_svd_t>())).S as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(S)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_svd_t>())).V as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_svd_t),
            "::",
            stringify!(V)
        )
    );
}
extern "C" {
    #[doc = " Compute a complete SVD of a matrix. The SVD exists for all"]
    #[doc = " matrices. For a matrix MxN, we will have:"]
    #[doc = ""]
    #[doc = " A = U*S*V'"]
    #[doc = ""]
    #[doc = " where A is MxN, U is MxM (and is an orthonormal basis), S is MxN"]
    #[doc = " (and is diagonal up to machine precision), and V is NxN (and is an"]
    #[doc = " orthonormal basis)."]
    #[doc = ""]
    #[doc = " The caller is responsible for destroying U, S, and V."]
    pub fn matd_svd(A: *mut matd_t) -> matd_svd_t;
}
extern "C" {
    pub fn matd_svd_flags(A: *mut matd_t, flags: ::std::os::raw::c_int) -> matd_svd_t;
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_plu_t {
    pub singular: ::std::os::raw::c_int,
    pub piv: *mut ::std::os::raw::c_uint,
    pub pivsign: ::std::os::raw::c_int,
    pub lu: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_plu_t() {
    assert_eq!(
        ::std::mem::size_of::<matd_plu_t>(),
        32usize,
        concat!("Size of: ", stringify!(matd_plu_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_plu_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_plu_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_plu_t>())).singular as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(singular)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_plu_t>())).piv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(piv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_plu_t>())).pivsign as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(pivsign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_plu_t>())).lu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_plu_t),
            "::",
            stringify!(lu)
        )
    );
}
extern "C" {
    pub fn matd_plu(a: *const matd_t) -> *mut matd_plu_t;
}
extern "C" {
    pub fn matd_plu_destroy(mlu: *mut matd_plu_t);
}
extern "C" {
    pub fn matd_plu_det(lu: *const matd_plu_t) -> f64;
}
extern "C" {
    pub fn matd_plu_p(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_l(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_u(lu: *const matd_plu_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_plu_solve(mlu: *const matd_plu_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_solve(A: *mut matd_t, b: *mut matd_t) -> *mut matd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matd_chol_t {
    pub is_spd: ::std::os::raw::c_int,
    pub u: *mut matd_t,
}
#[test]
fn bindgen_test_layout_matd_chol_t() {
    assert_eq!(
        ::std::mem::size_of::<matd_chol_t>(),
        16usize,
        concat!("Size of: ", stringify!(matd_chol_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_chol_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_chol_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_chol_t>())).is_spd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(is_spd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<matd_chol_t>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matd_chol_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn matd_chol(A: *mut matd_t) -> *mut matd_chol_t;
}
extern "C" {
    pub fn matd_chol_solve(chol: *const matd_chol_t, b: *const matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_chol_destroy(chol: *mut matd_chol_t);
}
extern "C" {
    pub fn matd_chol_inverse(a: *mut matd_t) -> *mut matd_t;
}
extern "C" {
    pub fn matd_ltransposetriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_ltriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_utriangle_solve(u: *mut matd_t, b: *const f64, x: *mut f64);
}
extern "C" {
    pub fn matd_max(m: *mut matd_t) -> f64;
}
pub type image_u8_t = image_u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8() {
    assert_eq!(
        ::std::mem::size_of::<image_u8>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x3_t = image_u8x3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x3 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x3() {
    assert_eq!(
        ::std::mem::size_of::<image_u8x3>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x3))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x3>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x3>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x3>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x3>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x3>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x3),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8x4_t = image_u8x4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8x4 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8x4() {
    assert_eq!(
        ::std::mem::size_of::<image_u8x4>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8x4))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8x4>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8x4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x4>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x4>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x4>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8x4>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8x4),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_f32_t = image_f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_f32 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut f32,
}
#[test]
fn bindgen_test_layout_image_f32() {
    assert_eq!(
        ::std::mem::size_of::<image_f32>(),
        24usize,
        concat!("Size of: ", stringify!(image_f32))
    );
    assert_eq!(
        ::std::mem::align_of::<image_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(image_f32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_f32>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_f32>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_f32>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_f32>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_f32),
            "::",
            stringify!(buf)
        )
    );
}
pub type image_u8_lut_t = image_u8_lut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_u8_lut {
    pub scale: f32,
    pub nvalues: ::std::os::raw::c_int,
    pub values: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8_lut() {
    assert_eq!(
        ::std::mem::size_of::<image_u8_lut>(),
        16usize,
        concat!("Size of: ", stringify!(image_u8_lut))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8_lut>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8_lut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8_lut>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8_lut>())).nvalues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(nvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8_lut>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8_lut),
            "::",
            stringify!(values)
        )
    );
}
extern "C" {
    pub fn image_u8_create_stride(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        stride: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_alignment(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_f32(fim: *mut image_f32_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm(path: *const ::std::os::raw::c_char) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_create_from_pnm_alignment(
        path: *const ::std::os::raw::c_char,
        alignment: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_copy(in_: *const image_u8_t) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_draw_line(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        v: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_circle(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_draw_annulus(
        im: *mut image_u8_t,
        x0: f32,
        y0: f32,
        r0: f32,
        r1: f32,
        v: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn image_u8_fill_line_max(
        im: *mut image_u8_t,
        lut: *const image_u8_lut_t,
        xy0: *const f32,
        xy1: *const f32,
    );
}
extern "C" {
    pub fn image_u8_clear(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_darken(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_convolve_2D(im: *mut image_u8_t, k: *const u8, ksz: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_gaussian_blur(im: *mut image_u8_t, sigma: f64, k: ::std::os::raw::c_int);
}
extern "C" {
    pub fn image_u8_decimate(im: *mut image_u8_t, factor: f32) -> *mut image_u8_t;
}
extern "C" {
    pub fn image_u8_destroy(im: *mut image_u8_t);
}
extern "C" {
    pub fn image_u8_write_pnm(
        im: *const image_u8_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn image_u8_rotate(in_: *const image_u8_t, rad: f64, pad: u8) -> *mut image_u8_t;
}
#[doc = " Defines a structure which acts as a resize-able array ala Java's ArrayList."]
pub type zarray_t = zarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zarray {
    pub el_sz: size_t,
    pub size: ::std::os::raw::c_int,
    pub alloc: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_zarray() {
    assert_eq!(
        ::std::mem::size_of::<zarray>(),
        24usize,
        concat!("Size of: ", stringify!(zarray))
    );
    assert_eq!(
        ::std::mem::align_of::<zarray>(),
        8usize,
        concat!("Alignment of ", stringify!(zarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).el_sz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(el_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).alloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Calls the supplied function for every element in the array in index order."]
    #[doc = " HOWEVER values are passed to the function, not pointers to values. In the"]
    #[doc = " case where the zarray stores object pointers, zarray_vmap allows you to"]
    #[doc = " pass in the object's destroy function (or free) directly. Can only be used"]
    #[doc = " with zarray's which contain pointer data. The map function should have the"]
    #[doc = " following format:"]
    #[doc = ""]
    #[doc = " void map_function(element_type *element)"]
    pub fn zarray_vmap(za: *mut zarray_t, f: ::std::option::Option<unsafe extern "C" fn()>);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workerpool {
    _unused: [u8; 0],
}
pub type workerpool_t = workerpool;
pub type timeprofile_t = timeprofile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeprofile {
    pub utime: i64,
    pub stamps: *mut zarray_t,
}
#[test]
fn bindgen_test_layout_timeprofile() {
    assert_eq!(
        ::std::mem::size_of::<timeprofile>(),
        16usize,
        concat!("Size of: ", stringify!(timeprofile))
    );
    assert_eq!(
        ::std::mem::align_of::<timeprofile>(),
        8usize,
        concat!("Alignment of ", stringify!(timeprofile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeprofile>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeprofile>())).stamps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(stamps)
        )
    );
}
pub type apriltag_family_t = apriltag_family;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_family {
    pub ncodes: u32,
    pub codes: *mut u64,
    pub width_at_border: ::std::os::raw::c_int,
    pub total_width: ::std::os::raw::c_int,
    pub reversed_border: bool,
    pub nbits: u32,
    pub bit_x: *mut u32,
    pub bit_y: *mut u32,
    pub h: u32,
    pub name: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_apriltag_family() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_family>(),
        72usize,
        concat!("Size of: ", stringify!(apriltag_family))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_family>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_family))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).ncodes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(ncodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).codes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(codes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).width_at_border as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(width_at_border)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).total_width as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(total_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).reversed_border as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(reversed_border)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).nbits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).bit_x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).bit_y as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).h as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).impl_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_quad_thresh_params {
    pub min_cluster_pixels: ::std::os::raw::c_int,
    pub max_nmaxima: ::std::os::raw::c_int,
    pub critical_rad: f32,
    pub cos_critical_rad: f32,
    pub max_line_fit_mse: f32,
    pub min_white_black_diff: ::std::os::raw::c_int,
    pub deglitch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apriltag_quad_thresh_params() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_quad_thresh_params>(),
        28usize,
        concat!("Size of: ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_quad_thresh_params>(),
        4usize,
        concat!("Alignment of ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).min_cluster_pixels as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_cluster_pixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).max_nmaxima as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_nmaxima)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).critical_rad as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(critical_rad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).cos_critical_rad as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(cos_critical_rad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).max_line_fit_mse as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_line_fit_mse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).min_white_black_diff as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_white_black_diff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).deglitch as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(deglitch)
        )
    );
}
pub type apriltag_detector_t = apriltag_detector;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apriltag_detector {
    #[doc = ""]
    pub nthreads: ::std::os::raw::c_int,
    pub quad_decimate: f32,
    pub quad_sigma: f32,
    pub refine_edges: ::std::os::raw::c_int,
    pub decode_sharpening: f64,
    pub debug: ::std::os::raw::c_int,
    pub qtp: apriltag_quad_thresh_params,
    #[doc = ""]
    pub tp: *mut timeprofile_t,
    pub nedges: u32,
    pub nsegments: u32,
    pub nquads: u32,
    pub tag_families: *mut zarray_t,
    pub wp: *mut workerpool_t,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_apriltag_detector() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_detector>(),
        136usize,
        concat!("Size of: ", stringify!(apriltag_detector))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detector>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nthreads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).quad_decimate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_decimate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).quad_sigma as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).refine_edges as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(refine_edges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_detector>())).decode_sharpening as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(decode_sharpening)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).debug as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).qtp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(qtp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).tp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nedges as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nsegments as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nsegments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nquads as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nquads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).tag_families as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tag_families)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).wp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).mutex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(mutex)
        )
    );
}
pub type apriltag_detection_t = apriltag_detection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection {
    pub family: *mut apriltag_family_t,
    pub id: ::std::os::raw::c_int,
    pub hamming: ::std::os::raw::c_int,
    pub decision_margin: f32,
    pub H: *mut matd_t,
    pub c: [f64; 2usize],
    pub p: [[f64; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_apriltag_detection() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection>(),
        112usize,
        concat!("Size of: ", stringify!(apriltag_detection))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).hamming as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(hamming)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_detection>())).decision_margin as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(decision_margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).H as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).c as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).p as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(p)
        )
    );
}
extern "C" {
    pub fn apriltag_detector_create() -> *mut apriltag_detector_t;
}
extern "C" {
    pub fn apriltag_detector_add_family_bits(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
        bits_corrected: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn apriltag_detector_remove_family(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
    );
}
extern "C" {
    pub fn apriltag_detector_clear_families(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_destroy(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_detect(
        td: *mut apriltag_detector_t,
        im_orig: *mut image_u8_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn apriltag_detection_destroy(det: *mut apriltag_detection_t);
}
extern "C" {
    pub fn apriltag_detections_destroy(detections: *mut zarray_t);
}
extern "C" {
    pub fn apriltag_to_image(
        fam: *mut apriltag_family_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut image_u8_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_detection_info_t {
    pub det: *mut apriltag_detection_t,
    pub tagsize: f64,
    pub fx: f64,
    pub fy: f64,
    pub cx: f64,
    pub cy: f64,
}
#[test]
fn bindgen_test_layout_apriltag_detection_info_t() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection_info_t>())).det as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(det)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_detection_info_t>())).tagsize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(tagsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection_info_t>())).fx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection_info_t>())).fy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection_info_t>())).cx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection_info_t>())).cy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection_info_t),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apriltag_pose_t {
    pub R: *mut matd_t,
    pub t: *mut matd_t,
}
#[test]
fn bindgen_test_layout_apriltag_pose_t() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_pose_t>(),
        16usize,
        concat!("Size of: ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_pose_t>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_pose_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_pose_t>())).R as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_pose_t>())).t as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_pose_t),
            "::",
            stringify!(t)
        )
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag using the homography method described in [1]."]
    #[doc = " @outparam pose"]
    pub fn estimate_pose_for_tag_homography(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    );
}
extern "C" {
    #[doc = " Estimate pose of the tag. This returns one or two possible poses for the"]
    #[doc = " tag, along with the object-space error of each."]
    #[doc = ""]
    #[doc = " This uses the homography method described in [1] for the initial estimate."]
    #[doc = " Then Orthogonal Iteration [2] is used to refine this estimate. Then [3] is"]
    #[doc = " used to find a potential second local minima and Orthogonal Iteration is"]
    #[doc = " used to refine this second estimate."]
    #[doc = ""]
    #[doc = " [1]: E. Olson, Apriltag: A robust and flexible visual fiducial system, in"]
    #[doc = "      2011 IEEE International Conference on Robotics and Automation,"]
    #[doc = "      May 2011, pp. 34003407."]
    #[doc = " [2]: Lu, G. D. Hager and E. Mjolsness, \"Fast and globally convergent pose"]
    #[doc = "      estimation from video images,\" in IEEE Transactions on Pattern Analysis"]
    #[doc = "      and Machine Intelligence, vol. 22, no. 6, pp. 610-622, June 2000."]
    #[doc = "      doi: 10.1109/34.862199"]
    #[doc = " [3]: Schweighofer and A. Pinz, \"Robust Pose Estimation from a Planar Target,\""]
    #[doc = "      in IEEE Transactions on Pattern Analysis and Machine Intelligence,"]
    #[doc = "      vol. 28, no. 12, pp. 2024-2030, Dec. 2006.  doi: 10.1109/TPAMI.2006.252"]
    #[doc = ""]
    #[doc = " @outparam err1, pose1, err2, pose2"]
    pub fn estimate_tag_pose_orthogonal_iteration(
        info: *mut apriltag_detection_info_t,
        err1: *mut f64,
        pose1: *mut apriltag_pose_t,
        err2: *mut f64,
        pose2: *mut apriltag_pose_t,
        nIters: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Estimate tag pose."]
    #[doc = " This method is an easier to use interface to estimate_tag_pose_orthogonal_iteration."]
    #[doc = ""]
    #[doc = " @outparam pose"]
    #[doc = " @return Object-space error of returned pose."]
    pub fn estimate_tag_pose(
        info: *mut apriltag_detection_info_t,
        pose: *mut apriltag_pose_t,
    ) -> f64;
}
extern "C" {
    pub fn tag16h5_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag16h5_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag25h9_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag25h9_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag36h11_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag36h11_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle21h7_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle21h7_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle49h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle49h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCustom48h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCustom48h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard41h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard41h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard52h13_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard52h13_destroy(tf: *mut apriltag_family_t);
}
